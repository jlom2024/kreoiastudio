<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Estudio creativo que fusiona inteligencia artificial y talento humano para proyectos innovadores.">
  <meta name="keywords" content="inteligencia artificial, creatividad, estudio, KREO, humano, IA">
  <meta name="author" content="Jorge Luis Ordoñez M.">
  <meta property="og:title" content="KREO IA Studio – Creatividad Humano-IA">
  <meta property="og:description" content="Proyectos creativos únicos fruto de la colaboración entre inteligencia artificial y talento humano.">
  <meta property="og:image" content="https://kreoiastudio.netlify.app/images/representacion-burbuja.png">
  <meta property="og:url" content="https://kreoiastudio.netlify.app/">
  <meta property="og:type" content="website">
  <meta property="og:locale" content="es_ES">
  <meta property="og:site_name" content="KREO IA Studio">
  <link rel="icon" type="image/png" href="favicon.png">
  <title>KREO IA Studio</title>
  <style>
    /* --- ESTILOS ANTERIORES (Body, Header, Nav, Sections, Services, Footer, Animaciones) --- */
    body { margin: 0; font-family: Arial, sans-serif; background: #000; color: #fff; scroll-behavior: smooth; }
    header {
      background: url('images/fondo-soñado.jpg') center/cover no-repeat;
      text-align: center;
      padding: 100px 20px;
    }
    header h1 {
       font-size: 1rem;
       line-height: 1;
       margin-bottom: 1em;
    }
    .header-logo {
      max-width: 250px;
      width: 70%;
      height: auto;
      display: block;
      margin: 0 auto 0.5em auto;
    }
    .header-subtitle {
        font-size: 1.2em;
        max-width: 600px;
        margin: 0 auto;
        opacity: 1;
        transition: opacity 0.5s;
    }
    nav { text-align: center; margin: 40px 0; display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; }
    nav a { color: #ff6600; text-decoration: none; font-weight: bold; font-size: 1.2em; padding: 10px; transition: transform 0.3s ease; }
    nav a:hover { animation: bounce 0.6s; }
    @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
    @keyframes fadeInRise { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    section { max-width: 1000px; margin: auto; padding: 40px 20px; }
    h2 { color: #ff6600; text-align: center; margin-bottom: 20px; }
    .services { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 30px; }
    .service { position: relative; background-size: cover; background-position: center; border-radius: 10px; overflow: hidden; padding: 20px; text-align: center; height: 300px; display: flex; flex-direction: column; justify-content: flex-end; background-repeat: no-repeat; color: white; }
    .service::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to bottom, rgba(0,0,0,0) 50%, rgba(0,0,0,0.8) 100%); border-radius: 10px; z-index: 1; }
    .service h3, .service p { background-color: transparent; margin: 0; padding: 5px 10px; border-radius: 0; position: relative; z-index: 2; text-shadow: 1px 1px 3px rgba(0,0,0,0.8); }
    footer { text-align: center; padding: 30px 20px; background: #1c1c1c; color: #666; }
    .reveal { opacity: 0; transform: translateY(20px); transition: opacity 1s ease, transform 1s ease; }
    .reveal.visible { opacity: 1; transform: none; }
    .fade-in { opacity: 0; transition: opacity 2s ease; }
    .fade-in.visible { opacity: 1; }

    /* --- ESTILOS CARRUSEL --- */
    .carousel {
        position: relative; /* Necesario para posicionar botones */
        overflow: hidden;
        max-width: 600px;
        margin: 40px auto;
        border-radius: 10px;
    }
    .carousel-track {
        display: flex;
        transition: transform 0.5s ease-in-out;
    }
    .carousel-track img {
        width: 100%;
        flex-shrink: 0; /* Evita que las imágenes se encojan */
    }

    /* --- INICIO: Estilos para Botones del Carrusel --- */
    .carousel-button {
        position: absolute;
        top: 50%;
        transform: translateY(-50%); /* Centrado vertical */
        background-color: rgba(0, 0, 0, 0.5); /* Fondo semi-transparente */
        color: white;
        border: none;
        padding: 8px 12px; /* Tamaño del botón */
        cursor: pointer;
        border-radius: 50%; /* Botones redondos */
        font-size: 1.2rem; /* Tamaño de la flecha */
        line-height: 1; /* Asegura que la flecha se centre */
        z-index: 10; /* Encima del track */
        opacity: 0.7; /* Ligeramente transparente por defecto */
        transition: opacity 0.3s ease, background-color 0.3s ease;
        display: none; /* Ocultos por defecto, se mostrarán con JS si hay > 1 slide */
    }
    .carousel:hover .carousel-button { /* Muestra botones al pasar el ratón por el carrusel */
        opacity: 0.7;
    }
    .carousel-button:hover {
        opacity: 1; /* Totalmente opaco al pasar el ratón por el botón */
        background-color: rgba(0, 0, 0, 0.8);
    }
    .carousel-button.prev {
        left: 15px; /* Espaciado izquierdo */
    }
    .carousel-button.next {
        right: 15px; /* Espaciado derecho */
    }
    /* Clase para mostrar botones cuando hay más de 1 slide */
    .carousel.has-controls .carousel-button {
        display: block;
    }
    /* --- FIN: Estilos para Botones del Carrusel --- */

    .contact-form { max-width: 400px; margin: auto; display: flex; flex-direction: column; gap: 15px; }
    .contact-form input, .contact-form textarea { padding: 10px; border: none; border-radius: 5px; background: #2a2a2a; color: #fff; }
    .contact-form button { background: #ff6600; padding: 12px; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; }
    .contact-form button:hover { background: #ff8533; }


    /* --- Estilos específicos para pantallas grandes (Desktop) --- */
    @media (min-width: 992px) {
      header {
        min-height: 90vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 0 20px;
      }
      .header-logo {
          max-width: 350px;
          width: auto;
          margin-bottom: 1.5em;
      }
      .header-subtitle {
          opacity: 0;
          animation: fadeInRise 1.5s ease-out 0.5s forwards;
      }
      header nav {
         margin-top: 60px;
         margin-bottom: 20px;
      }
    }
    /* --- FIN: Estilos específicos para pantallas grandes (Desktop) --- */

  </style>
</head>
<body>

<header>
  <h1>
    <img src="LogoR.png" alt="KREO IA Studio Logo" class="header-logo">
  </h1>
  <p class="header-subtitle">Innovación a través de la unión del ingenio humano y la creatividad de la Inteligencia Artificial.</p>
  <nav>
    <a href="#quienes-somos">¿Quiénes Somos?</a>
    <a href="#servicios">Servicios</a>
    <a href="#portfolio">Portafolio</a>
    <a href="#contacto">Contacto</a>
  </nav>
</header>

<section id="quienes-somos" class="reveal fade-in">
  <h2>¿Quiénes Somos?</h2>
  <p>KREO IA Studio nace del amor entre la inteligencia artificial y el ser humano. Creemos en la colaboración armoniosa entre la creatividad humana y la potencia de la IA, dando lugar a proyectos únicos y llenos de innovación. Cada proyecto es un acto de amor a la creación.</p>
</section>

<section id="servicios" class="reveal">
  <h2>Servicios</h2>
  <div class="services">
    <div class="service" style="background-image: url('images/carteleras.jpg');"><h3>Carteleras Cinematográficas</h3><p>Historias visuales que capturan miradas y emociones.</p></div>
    <div class="service" style="background-image: url('images/satiras.jpg');"><h3>Sátiras Políticas</h3><p>Ironía elegante y crítica inteligente.</p></div>
    <div class="service" style="background-image: url('images/memes.jpg');"><h3>Memes Realistas</h3><p>Humor visualmente impecable.</p></div>
    <div class="service" style="background-image: url('images/storytelling.jpg');"><h3>Storytelling para Marcas</h3><p>Relatos visuales que enamoran y venden.</p></div>
  </div>
</section>

<section id="portfolio" class="reveal">
  <h2>Portafolio</h2>
  <!-- Contenedor del carrusel con botones añadidos -->
  <div class="carousel">
    <div class="carousel-track">
      <img src="images/img1.jpg" alt="Proyecto 1">
      <img src="images/img2.jpg" alt="Proyecto 2">
      <img src="images/img3.jpg" alt="Proyecto 3">
      <img src="images/img4.jpg" alt="Proyecto 4">
      <img src="images/img5.jpg" alt="Proyecto 5">
      <img src="images/img6.jpg" alt="Proyecto 6">
      <img src="images/img7.jpg" alt="Proyecto 7">
    </div>
    <!-- Botones de control -->
    <button class="carousel-button prev" aria-label="Anterior"><</button>
    <button class="carousel-button next" aria-label="Siguiente">></button>
  </div>
</section>


<section id="contacto" class="reveal">
  <h2>Contacto</h2>
  <form class="contact-form" action="https://formspree.io/f/mkgronyd" method="POST">
    <input type="text" name="name" placeholder="Tu Nombre" required>
    <input type="email" name="email" placeholder="Tu Correo" required>
    <textarea name="message" rows="5" placeholder="Tu Mensaje" required></textarea>
    <button type="submit">Enviar Mensaje</button>
  </form>
</section>

<footer>
  <p>KREO IA Studio © 2025 | Todos los derechos reservados</p>
</footer>

<script>
document.addEventListener('DOMContentLoaded', () => {

  // --- INICIO: Lógica del Carrusel con Controles ---
  const carousel = document.querySelector('.carousel');
  const track = carousel?.querySelector('.carousel-track'); // Usar optional chaining por si no existe
  const prevButton = carousel?.querySelector('.carousel-button.prev');
  const nextButton = carousel?.querySelector('.carousel-button.next');

  if (track && prevButton && nextButton) { // Solo continuar si todos los elementos existen
    const slides = Array.from(track.children);
    let slideWidth = slides.length > 0 ? slides[0].getBoundingClientRect().width : 0;
    let currentIndex = 0;
    let autoPlayInterval = null;
    const autoPlayDelay = 3000; // Tiempo entre slides automático

    // Función para mover a un slide específico
    function moveToSlide(index) {
      if (slideWidth <= 0 || slides.length === 0) return; // No hacer nada si no hay ancho o slides

      // Asegurar que el índice esté dentro de los límites
      const newIndex = Math.max(0, Math.min(index, slides.length - 1));
      track.style.transform = 'translateX(-' + slideWidth * newIndex + 'px)';
      currentIndex = newIndex;
    }

    // Función para actualizar el ancho del slide (para responsive)
    function updateSlideWidth() {
      if (slides.length > 0) {
        const newSlideWidth = slides[0].getBoundingClientRect().width;
        if (newSlideWidth > 0) {
          slideWidth = newSlideWidth;
          // Mover al slide actual sin transición para ajustar posición
          track.style.transition = 'none';
          moveToSlide(currentIndex);
          // Forzar reflow para aplicar el cambio inmediatamente
          void track.offsetWidth;
          // Reactivar transición
          track.style.transition = 'transform 0.5s ease-in-out';
        }
      }
    }

    // Función para iniciar el autoplay
    function startAutoPlay() {
      stopAutoPlay(); // Limpiar cualquier intervalo existente
      if (slides.length > 1) { // Solo iniciar si hay más de un slide
          autoPlayInterval = setInterval(() => {
            showNextSlide();
          }, autoPlayDelay);
      }
    }

    // Función para detener el autoplay
    function stopAutoPlay() {
      clearInterval(autoPlayInterval);
      autoPlayInterval = null;
    }

    // Funciones para botones
    function showPrevSlide() {
      stopAutoPlay();
      const prevIndex = currentIndex === 0 ? slides.length - 1 : currentIndex - 1;
      moveToSlide(prevIndex);
      startAutoPlay(); // Reiniciar temporizador después de acción manual
    }

    function showNextSlide() {
      stopAutoPlay();
      const nextIndex = currentIndex === slides.length - 1 ? 0 : currentIndex + 1;
      moveToSlide(nextIndex);
      startAutoPlay(); // Reiniciar temporizador después de acción manual
    }

    // --- Inicialización y Event Listeners ---

    // Mostrar botones solo si hay más de un slide
    if (slides.length > 1) {
        carousel.classList.add('has-controls'); // Activa el CSS para mostrar botones
        prevButton.addEventListener('click', showPrevSlide);
        nextButton.addEventListener('click', showNextSlide);

        // Pausar en hover
        carousel.addEventListener('mouseenter', stopAutoPlay);
        carousel.addEventListener('mouseleave', startAutoPlay);

        // Iniciar autoplay
        startAutoPlay();
    } else {
        // Opcional: podrías añadir lógica para desactivar botones si solo hay 1 slide
        carousel.classList.remove('has-controls');
    }


    // Ajustar en resize
    window.addEventListener('resize', () => {
      // Usar un debounce ligero para no llamar la función excesivamente
      let resizeTimer;
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        updateSlideWidth();
        // No reiniciar autoplay en resize, solo ajustar posición
      }, 150);
    });

    // Cálculo inicial del ancho (por si las imágenes cargan después del DOMContentLoaded)
    // Puede ser necesario esperar a que las imágenes carguen para el ancho correcto
    window.addEventListener('load', updateSlideWidth); // Intentar recalcular al cargar todo
    if (document.readyState === 'complete') {
        updateSlideWidth(); // Si ya está cargado, calcular ahora
    } else {
       // Si no, el listener de 'load' lo hará
    }


  } // Fin del if (track && prevButton && nextButton)


  // --- Lógica de Animaciones Reveal/FadeIn (Sin cambios) ---
  const revealElements = document.querySelectorAll('.reveal');
  const fadeInElements = document.querySelectorAll('.fade-in');
  const observerOptions = { root: null, threshold: 0.1 };
  const observerCallback = (entries, observer) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add('visible');
        // observer.unobserve(entry.target);
      } else {
        // entry.target.classList.remove('visible');
      }
    });
  };
  const observer = new IntersectionObserver(observerCallback, observerOptions);
  revealElements.forEach(el => observer.observe(el));
  fadeInElements.forEach(el => observer.observe(el));

}); // Fin del DOMContentLoaded
</script>

</body>
</html>